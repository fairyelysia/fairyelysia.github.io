(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{353:function(e,t,v){"use strict";v.r(t);var a=v(42),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),v("h2",{attrs:{id:"_1-vue的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的优点"}},[e._v("#")]),e._v(" 1.vue的优点")]),e._v(" "),v("ul",[v("li",[e._v("轻量级框架")]),e._v(" "),v("li",[e._v("简单易学")]),e._v(" "),v("li",[e._v("双向数据绑定")]),e._v(" "),v("li",[e._v("组件化")]),e._v(" "),v("li",[e._v("视图，数据，结构分离")]),e._v(" "),v("li",[e._v("虚拟dom")]),e._v(" "),v("li",[e._v("运行速度快")])]),e._v(" "),v("h2",{attrs:{id:"_2-请详细说下你对vue生命周期的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-请详细说下你对vue生命周期的理解"}},[e._v("#")]),e._v(" 2.请详细说下你对vue生命周期的理解")]),e._v(" "),v("blockquote",[v("p",[e._v("总共8个阶段，创建前/后，载入前/后，更新前/后，销毁前/后。")])]),e._v(" "),v("ul",[v("li",[e._v("创建前/后： 在"),v("strong",[e._v("beforeCreate")]),e._v("阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在"),v("strong",[e._v("created")]),e._v("阶段，vue实例的数据对象data有了，el为undefined，还未初始化。")]),e._v(" "),v("li",[e._v("载入前/后：在"),v("strong",[e._v("beforeMount")]),e._v("阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在"),v("strong",[e._v("mounted")]),e._v("阶段，vue实例挂载完成，data.message成功渲染。")]),e._v(" "),v("li",[e._v("更新前/后：当data变化时，会触发"),v("strong",[e._v("beforeUpdate")]),e._v("和"),v("strong",[e._v("updated")]),e._v("方法")]),e._v(" "),v("li",[e._v("销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在")])]),e._v(" "),v("h2",{attrs:{id:"_3-为什么vue组件中data必须是一个函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么vue组件中data必须是一个函数"}},[e._v("#")]),e._v(" 3.为什么vue组件中data必须是一个函数")]),e._v(" "),v("ul",[v("li",[e._v("对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。")])]),e._v(" "),v("h2",{attrs:{id:"_4-vue数据双向绑定原理；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue数据双向绑定原理；"}},[e._v("#")]),e._v(" 4.vue数据双向绑定原理；")]),e._v(" "),v("p",[e._v("vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),e._v(" "),v("blockquote",[v("p",[e._v("1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")])]),e._v(" "),v("blockquote",[v("p",[e._v("2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")])]),e._v(" "),v("blockquote",[v("p",[e._v("3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")])]),e._v(" "),v("blockquote",[v("p",[e._v("4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")])]),e._v(" "),v("h2",{attrs:{id:"_5-vue-computed原理、computed和watch的区别；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-computed原理、computed和watch的区别；"}},[e._v("#")]),e._v(" 5.vue computed原理、computed和watch的区别；")]),e._v(" "),v("h2",{attrs:{id:"计算属性computed："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算属性computed："}},[e._v("#")]),e._v(" 计算属性computed：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("支持缓存，只有依赖数据发生改变，才会重新进行计算")])]),e._v(" "),v("li",[v("p",[e._v("不支持异步，当computed内有异步操作时无效，无法监听数据的变化")])]),e._v(" "),v("li",[v("p",[e._v("computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值")])]),e._v(" "),v("li",[v("p",[e._v("如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed")])]),e._v(" "),v("li",[v("p",[e._v("如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。")]),e._v(" "),v("h2",{attrs:{id:"侦听属性watch："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#侦听属性watch："}},[e._v("#")]),e._v(" 侦听属性watch：")])]),e._v(" "),v("li",[v("p",[e._v("不支持缓存，数据变，直接会触发相应的操作；")])]),e._v(" "),v("li",[v("p",[e._v("watch支持异步；")])]),e._v(" "),v("li",[v("p",[e._v("监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；")])]),e._v(" "),v("li",[v("p",[e._v("当一个属性发生变化时，需要执行对应的操作；一对多；")])]),e._v(" "),v("li",[v("p",[e._v("监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：")])])]),e._v(" "),v("h2",{attrs:{id:"_4-mvvm模式、mvc模式理解；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm模式、mvc模式理解；"}},[e._v("#")]),e._v(" 4.mvvm模式、mvc模式理解；")]),e._v(" "),v("p",[e._v("『View』：视图层（UI 用户界面）\n『ViewModel』：业务逻辑层（一切 js 可视为业务逻辑）\n『Model』：数据层（存储数据及对数据的处理如增删改查）")]),e._v(" "),v("ul",[v("li",[e._v("MVVM 将数据双向绑定（data-binding）作为核心思想，View 和 Model 之间没有联系，它们通过 ViewModel 这个桥梁进行交互。")]),e._v(" "),v("li",[e._v("Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。")]),e._v(" "),v("li",[e._v("当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。")])]),e._v(" "),v("h2",{attrs:{id:"简述-mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简述-mvvm"}},[e._v("#")]),e._v(" 简述 MVVM")]),e._v(" "),v("ul",[v("li",[e._v("MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。")]),e._v(" "),v("li",[e._v("在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。")]),e._v(" "),v("li",[e._v("ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。")])]),e._v(" "),v("h2",{attrs:{id:"_5-v-on可以监听多个方法吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-v-on可以监听多个方法吗？"}},[e._v("#")]),e._v(" 5.v-on可以监听多个方法吗？")]),e._v(" "),v("p",[e._v("可以")]),e._v(" "),v("h2",{attrs:{id:"_6-vue如何获取dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue如何获取dom"}},[e._v("#")]),e._v(" 6.vue如何获取dom")]),e._v(" "),v("p",[e._v("ref 通过this.$refs.test")]),e._v(" "),v("h2",{attrs:{id:"_7-assets和static的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-assets和static的区别"}},[e._v("#")]),e._v(" 7.assets和static的区别")]),e._v(" "),v("ul",[v("li",[e._v("这两个都是用来存放项目中所使用的静态资源文件。")]),e._v(" "),v("li",[e._v("两者的区别：")]),e._v(" "),v("li",[e._v("assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。")]),e._v(" "),v("li",[e._v("static中的文件则不会被打包。")])]),e._v(" "),v("blockquote",[v("p",[e._v("建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。")])]),e._v(" "),v("h2",{attrs:{id:"_8-vue初始化页面的闪动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue初始化页面的闪动"}},[e._v("#")]),e._v(" 8.vue初始化页面的闪动")]),e._v(" "),v("div",{staticClass:"language-css line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-css"}},[v("code",[v("span",{pre:!0,attrs:{class:"token selector"}},[e._v("[v-cloak]")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),v("span",{pre:!0,attrs:{class:"token property"}},[e._v("display")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("none\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br")])]),v("blockquote",[v("p",[e._v('如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: \'block\'}"')])]),e._v(" "),v("h2",{attrs:{id:"_9-vuex中有几个核心属性，分别是什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-vuex中有几个核心属性，分别是什么？"}},[e._v("#")]),e._v(" 9.vuex中有几个核心属性，分别是什么？")]),e._v(" "),v("p",[e._v("一共有5个核心属性，分别是:")]),e._v(" "),v("ol",[v("li",[e._v("state 唯一数据源,Vue 实例中的 data 遵循相同的规则")]),e._v(" "),v("li",[e._v("getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.")]),e._v(" "),v("li",[e._v("mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发")]),e._v(" "),v("li",[e._v("action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作")]),e._v(" "),v("li",[e._v("module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）")])]),e._v(" "),v("h2",{attrs:{id:"_10-vuex中的数据在页面刷新后数据消失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-vuex中的数据在页面刷新后数据消失"}},[e._v("#")]),e._v(" 10.vuex中的数据在页面刷新后数据消失")]),e._v(" "),v("p",[e._v("​\t用sessionstorage 或者 localstorage 存储数据")]),e._v(" "),v("h2",{attrs:{id:"_11-vue-router"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-router"}},[e._v("#")]),e._v(" 11.vue-router")]),e._v(" "),v("p",[e._v("Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：")]),e._v(" "),v("ul",[v("li",[e._v("嵌套的路由/视图表")]),e._v(" "),v("li",[e._v("模块化的、基于组件的路由配置")]),e._v(" "),v("li",[e._v("路由参数、查询、通配符")]),e._v(" "),v("li",[e._v("基于 Vue.js 过渡系统的视图过渡效果")]),e._v(" "),v("li",[e._v("细粒度的导航控制")]),e._v(" "),v("li",[e._v("带有自动激活的 CSS class 的链接")]),e._v(" "),v("li",[e._v("HTML5 历史模式或 hash 模式，在 IE9 中自动降级")]),e._v(" "),v("li",[e._v("自定义的滚动条行为")])]),e._v(" "),v("h2",{attrs:{id:"_12-vue-router导航钩子"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-router导航钩子"}},[e._v("#")]),e._v(" 12.vue-router导航钩子")]),e._v(" "),v("p",[e._v("​\t常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：")]),e._v(" "),v("ul",[v("li",[e._v("全局导航钩子：router.beforeEach(to,from,next)")]),e._v(" "),v("li",[e._v("组件内的钩子")]),e._v(" "),v("li",[e._v("单独路由独享组件")])]),e._v(" "),v("h2",{attrs:{id:"_13-vue路由传参"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue路由传参"}},[e._v("#")]),e._v(" 13.vue路由传参")]),e._v(" "),v("blockquote",[v("p",[e._v("使用query方法传入的参数使用this.$route.query接受")])]),e._v(" "),v("blockquote",[v("p",[e._v("使用params方式传入的参数使用this.$route.params接受")])]),e._v(" "),v("h2",{attrs:{id:"_14-router和route的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-router和route的区别"}},[e._v("#")]),e._v(" 14.router和route的区别")]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("route")]),e._v(" 为当前router跳转对象里面可以获取name、path、query、params等")])]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("router")]),e._v(" 为VueRouter实例，想要导航到不同URL，则使用router.push方法")])])])}),[],!1,null,null,null);t.default=_.exports}}]);